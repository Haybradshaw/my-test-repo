<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 6. Object Patterns</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="The Principles of Object-Oriented Javascript"/><link rel="prev" href="ch05.html" title="Chapter 5. Inheritance"/><link rel="next" href="pr05.html" title=" "/></head><body><section class="chapter" title="Chapter 6. Object Patterns" epub:type="chapter" id="object_patterns"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Object Patterns</h2></div></div></div><p><a id="iddle1226" class="indexterm"/>JavaScript has many patterns for creating objects, and there’s usually more than one way to accomplish the same thing. You can define your own custom types or your own generic objects whenever you want. You can use inheritance to share behavior between objects, or you can employ other techniques, such as mixins. You can also take advantage of advanced JavaScript features to prevent an object’s structure from being modified. The patterns discussed in this chapter give you powerful ways of managing and creating objects, all based on your use cases.</p><div class="sect1" title="Private and Privileged Members"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="private_and_privileged_members">Private and Privileged Members</h2></div></div></div><p><a id="iddle1009" class="indexterm"/><a id="iddle1015" class="indexterm"/><a id="iddle1144" class="indexterm"/><a id="iddle1186" class="indexterm"/><a id="iddle1191" class="indexterm"/><a id="iddle1194" class="indexterm"/><a id="iddle1227" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1269" class="indexterm"/><a id="iddle1378" class="indexterm"/>All object properties in JavaScript are public, and there’s no explicit way to indicate that a property shouldn’t be accessed from outside a particular object. At some point, however, you might not want data to be public. For example, when an object uses a value to determine some sort of state, modifying that data without the object’s knowledge throws the state management process into chaos. One way to avoid this is by using naming conventions. For example, it’s quite common to prefix properties with an underscore (such as <code class="literal">this._name</code>) when they are not intended to be public. However, there are ways of hiding data that don’t rely on convention and are therefore more “bulletproof” in preventing the modification of private information.</p><div class="sect2" title="The Module Pattern"><div class="titlepage"><div><div><h3 class="title" id="module_pattern">The Module Pattern</h3></div></div></div><p>The <span class="emphasis"><em>module pattern</em></span> is an object-creation pattern designed to create singleton objects with private data. The basic approach is to use an <span class="emphasis"><em>immediately invoked function expression (IIFE)</em></span> that returns an object. An IIFE is a function expression that is defined and then called immediately to produce a result. That function expression can contain any number of local variables that aren’t accessible from outside that function. Because the returned object is defined within that function, the object’s methods have access to the data. (All objects defined within the IIFE have access to the same local variables.) Methods that access private data in this way are called <span class="emphasis"><em>privileged</em></span> methods. Here’s the basic format for the module pattern:</p><a id="pro_id00115"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">yourObject</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>

      <span class="pd_green1"><code class="c1">// private data variables</code></span>

      <span class="pd_green"><code class="k">return</code></span> <code class="p">{</code>
          <span class="pd_green1"><code class="c1">// public methods and properties</code></span>
      <code class="p">};</code>
<code class="err">❶</code> <code class="p">}());</code></pre><p>In this pattern, an anonymous function is created and executed immediately. (Note the extra parentheses at the end of the function ❶. You can execute anonymous functions immediately using this syntax.) That means the function exists for just a moment, is executed, and then is destroyed. IIFEs are a very popular pattern in JavaScript, partially for their use in the module pattern.</p><p><a id="iddle1048" class="indexterm"/><a id="iddle1255" class="indexterm"/>The module pattern allows you to use regular variables as de facto object properties that aren’t exposed publicly. You accomplish this by creating <span class="emphasis"><em>closure</em></span> functions as object methods. Closures are simply functions that access data outside their own scope. For example, whenever you access a global object in a function, such as <code class="literal">window</code> in a web browser, that function is accessing a variable outside its own scope. The difference with the module function is that the variables are declared within the IIFE, and a function that is also declared inside the IIFE accesses those variables. For example:</p><a id="pro_id00116"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>

<code class="err">❶</code>     <span class="pd_green"><code class="kd">var</code></span> <code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">25</code></span><code class="p">;</code>

      <span class="pd_green"><code class="k">return</code></span> <code class="p">{</code>
          <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>

<code class="err">❷</code>         <code class="nx">getAge</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
              <span class="pd_green"><code class="k">return</code></span> <code class="nx">age</code><code class="p">;</code>
          <code class="literal">},</code>

<code class="err">❸</code>         <code class="nx">growOlder</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
              <code class="nx">age</code><code class="o">++</code><code class="p">;</code>
          <code class="literal">}</code>
      <code class="literal">};</code>

  <code class="literal">}());</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 25</code></span>

  <code class="nx">person</code><code class="p">.</code><code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">100</code></span><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 25</code></span>

  <code class="nx">person</code><code class="p">.</code><code class="nx">growOlder</code><code class="p">();</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 26</code></span></pre><p>This code creates the <code class="literal">person</code> object using the module pattern. The <code class="literal">age</code> variable ❶ acts like a private property for the object. It can’t be accessed directly from outside the object, but it can be used by the object methods. There are two privileged methods on the object: <code class="literal">getAge()</code> ❷, which reads the value of the <code class="literal">age</code> variable, and <code class="literal">growOlder()</code> ❸, which increments <code class="literal">age</code>. Both of these methods can access the variable <code class="literal">age</code> directly because it is defined in the outer function in which they are defined.</p><p><a id="iddle1061" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1325" class="indexterm"/>There is a variation of the module pattern called the <span class="emphasis"><em>revealing module pattern</em></span>, which arranges all variables and methods at the top of the IIFE and simply assigns them to the returned object. You can write the previous example using the revealing module pattern as follows:</p><a id="pro_id00117"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>

      <span class="pd_green"><code class="kd">var</code></span> <code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">25</code></span><code class="p">;</code>

      <span class="pd_green"><code class="kd">function</code></span> <code class="nx">getAge</code><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <code class="nx">age</code><code class="p">;</code>
      <code class="literal">}</code>

      <span class="pd_green"><code class="kd">function</code></span> <code class="nx">growOlder</code><code class="p">()</code> <code class="p">{</code>
          <code class="nx">age</code><code class="o">++</code><code class="p">;</code>
      <code class="literal">}</code>

      <span class="pd_green"><code class="k">return</code></span> <code class="p">{</code>
          <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>
<code class="err">❶</code>         <code class="nx">getAge</code><code class="o">:</code> <code class="nx">getAge</code><code class="p">,</code>
          <code class="nx">growOlder</code><code class="o">:</code> <code class="nx">growOlder</code>
      <code class="literal">};</code>

  <code class="literal">}());</code></pre><p>In the revealing module pattern, <code class="literal">age</code>, <code class="literal">getAge()</code>, and <code class="literal">growOlder()</code> are all defined as local to the IIFE. The <code class="literal">getAge()</code> and <code class="literal">growOlder()</code> functions are then assigned to the returned object ❶, effectively “revealing” them outside the IIFE. This code is essentially the same as the earlier example using the traditional module pattern; however, some prefer this pattern because it keeps all variable and function declarations together.</p></div><div class="sect2" title="Private Members for Constructors"><div class="titlepage"><div><div><h3 class="title" id="private_members_for_constructors">Private Members for Constructors</h3></div></div></div><p>The module pattern is great for defining individual objects that have private properties, but what about custom types that also require their own private properties? You can use a pattern that’s similar to the module pattern inside the constructor to create instance-specific private data. For example:</p><a id="pro_id00118"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>

      <span class="pd_green1"><code class="c1">// define a variable only accessible inside of the Person constructor</code></span>
      <span class="pd_green"><code class="kd">var</code></span> <code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">25</code></span><code class="p">;</code>

      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>

<code class="err">❶</code>     <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">getAge</code> <span class="pd_ash"><code class="o">=</code></span> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <code class="nx">age</code><code class="p">;</code>
      <code class="p">};</code>

<code class="err">❷</code>     <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">growOlder</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">age</code><code class="o">++</code><code class="p">;</code>
      <code class="p">};</code>
   <code class="p">}</code>

   <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>

   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 25</code></span>

   <code class="nx">person</code><code class="p">.</code><code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">100</code></span><code class="p">;</code>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 25</code></span>

   <code class="nx">person</code><code class="p">.</code><code class="nx">growOlder</code><code class="p">();</code>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>   <span class="pd_green1"><code class="c1">// 26</code></span></pre><p><a id="iddle1075" class="indexterm"/><a id="iddle1263" class="indexterm"/><a id="iddle1334" class="indexterm"/>In this code, the <code class="literal">Person</code> constructor has a local variable, <code class="literal">age</code>. That variable is used as part of the <code class="literal">getAge()</code> ❶ and <code class="literal">growOlder()</code> ❷ methods. When you create an instance of <code class="literal">Person</code>, that instance receives its own <code class="literal">age</code> variable, <code class="literal">getAge()</code> method, and <code class="literal">growOlder()</code> method. In many ways, this is similar to the module pattern, where the constructor creates a local scope and returns the <code class="literal">this</code> object. As discussed in <a class="xref" href="ch04.html" title="Chapter 4. Constructors and Prototypes">Chapter 4</a>, placing methods on an object instance is less efficient than doing so on the prototype, but this is the only approach possible when you want private, instance-specific data.</p><p>If you want private data to be shared across all instances (as if it were on the prototype), you can use a hybrid approach that looks like the module pattern but uses a constructor:</p><a id="pro_id00119"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">Person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>

      <span class="pd_green1"><code class="c1">// everyone shares the same age</code></span>
<code class="err">❶</code>     <span class="pd_green"><code class="kd">var</code></span> <code class="nx">age</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_ash"><code class="mi">25</code></span><code class="p">;</code>

<code class="err">❷</code>     <span class="pd_green"><code class="kd">function</code></span> <code class="nx">InnerPerson</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
      <code class="p">}</code>

      <code class="nx">InnerPerson</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getAge</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <code class="nx">age</code><code class="p">;</code>
      <code class="p">};</code>

      <code class="nx">InnerPerson</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">growOlder</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">age</code><code class="o">++</code><code class="p">;</code>
      <code class="p">};</code>

      <span class="pd_green"><code class="k">return</code></span> <code class="nx">InnerPerson</code><code class="p">;</code>

  <code class="p">}());</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>  <span class="pd_green1"><code class="c1">// 25</code></span>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// "Greg"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>  <span class="pd_green1"><code class="c1">// 25</code></span>

  <code class="nx">person1</code><code class="p">.</code><code class="nx">growOlder</code><code class="p">();</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>  <span class="pd_green1"><code class="c1">// 26</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">getAge</code><code class="p">());</code>  <span class="pd_green1"><code class="c1">// 26</code></span></pre><p><a id="iddle1096" class="indexterm"/><a id="iddle1113" class="indexterm"/><a id="iddle1189" class="indexterm"/><a id="iddle1271" class="indexterm"/><a id="iddle1309" class="indexterm"/><a id="iddle1313" class="indexterm"/><a id="iddle1356" class="indexterm"/>In this code, the <code class="literal">InnerPerson</code> constructor ❷ is defined inside an IIFE. The variable <code class="literal">age</code> ❶ is defined outside the constructor but is used for two prototype methods. The <code class="literal">InnerPerson</code> constructor is then returned and becomes the <code class="literal">Person</code> constructor in the global scope. All instances of <code class="literal">Person</code> end up sharing the <code class="literal">age</code> variable, so changing the value with one instance automatically affects the other instance.</p></div></div><div class="sect1" title="Mixins"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="mixins">Mixins</h2></div></div></div><p>Although pseudoclassical inheritance and prototypal inheritance are used frequently in JavaScript, there is also a type of pseudoinheritance accomplished through mixins. <span class="emphasis"><em>Mixins</em></span> occur when one object acquires the properties of another without modifying the prototype chain. The first object (a <span class="emphasis"><em>receiver</em></span>) actually receives the properties of the second object (the <span class="emphasis"><em>supplier</em></span>) by copying those properties directly. Traditionally, you create mixins using a function such as this:</p><a id="pro_id00120"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">mixin</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">for</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">var</code></span> <code class="nx">property</code> <span class="pd_green"><code class="k">in</code></span> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>
        <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><code class="nx">supplier</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">property</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">receiver</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">supplier</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <span class="pd_green"><code class="k">return</code></span> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">}</code></pre><p>The <code class="literal">mixin()</code> function accepts two arguments: the receiver and the supplier. The goal of the function is to copy all enumerable properties from the supplier onto the receiver. You accomplish this using a <code class="literal">for-in</code> loop that iterates over the properties in <code class="literal">supplier</code> and then assigns the value <a id="iddle1104" class="indexterm"/>of that property to a property of the same name on <code class="literal">receiver</code>. Keep in mind that this is a shallow copy, so if a property contains an object, then both the supplier and the receiver will be pointing to the same object. This pattern is used frequently for adding new behaviors to JavaScript objects that already exist on other objects.</p><p>For example, you can add event support to an object through a mixin rather than inheritance. First, suppose you’ve already defined a custom type for using events:</p><a id="pro_id00121"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">EventTarget</code><code class="p">(){</code>
  <code class="p">}</code>

  <code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>

      <code class="nx">constructor</code><code class="o">:</code> <code class="nx">EventTarget</code><code class="p">,</code>

<code class="err">❶</code>     <code class="nx">addListener</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">type</code><code class="p">,</code> <code class="nx">listener</code><code class="p">){</code>

          <span class="pd_green1"><code class="c1">// create an array if it doesn't exist</code></span>
          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_ash"><code class="o">!</code></span><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><span class="pd_red"><code class="s2">"_listeners"</code></span><code class="p">))</code> <code class="p">{</code>
              <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
          <code class="p">}</code>

          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="k">typeof</code> <code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">type</code><code class="p">]</code> <span class="pd_ash"><code class="o">==</code></span> <span class="pd_red"><code class="s2">"undefined"</code></span><code class="p">){</code>
              <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">type</code><code class="p">]</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>
          <code class="p">}</code>

          <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">type</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">listener</code><code class="p">);</code>
      <code class="p">},</code>

<code class="err">❷</code>     <code class="nx">fire</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">event</code><code class="p">){</code>

          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_ash"><code class="o">!</code></span><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">){</code>
              <code class="nx">event</code><code class="p">.</code><code class="nx">target</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">;</code>
          <code class="p">}</code>

          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_ash"><code class="o">!</code></span><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">){</code> <span class="pd_green1"><code class="c1">// falsy</code></span>
              <span class="pd_green"><code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"Event object missing 'type' property."</code></span><code class="p">);</code>
          <code class="p">}</code>

          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code> <span class="pd_ash"><code class="o">&amp;&amp;</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">]</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Array</code></span><code class="p">){</code>
              <span class="pd_green"><code class="kd">var</code></span> <code class="nx">listeners</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code class="p">];</code>
              <span class="pd_green"><code class="k">for</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">var</code></span> <span class="pd_ash"><code class="nx">i</code><code class="o">=</code><code class="mi">0</code></span><code class="p">,</code> <code class="nx">len</code><span class="pd_ash"><code class="o">=</code></span><code class="nx">listeners</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <span class="pd_ash"><code class="o">&lt;</code></span> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><span class="pd_ash"><code class="o">++</code></span><code class="p">){</code>
                  <code class="nx">listeners</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">event</code><code class="p">);</code>
              <code class="p">}</code>
          <code class="p">}</code>
      <code class="p">},</code>
<code class="err">❸</code>     <code class="nx">removeListener</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">type</code><code class="p">,</code> <code class="nx">listener</code><code class="p">){</code>
          <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code> <span class="pd_ash"><code class="o">&amp;&amp;</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">type</code><code class="p">]</code> <span class="pd_green"><code class="k">instanceof</code> <code class="nb">Array</code></span><code class="p">){</code>
              <span class="pd_green"><code class="kd">var</code></span> <code class="nx">listeners</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">_listeners</code><code class="p">[</code><code class="nx">type</code><code class="p">];</code>
              <span class="pd_green"><code class="k">for</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">var</code></span> <span class="pd_ash"><code class="nx">i</code><code class="o">=</code><code class="mi">0</code></span><code class="p">,</code> <code class="nx">len</code><span class="pd_ash"><code class="o">=</code></span><code class="nx">listeners</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <span class="pd_ash"><code class="o">&lt;</code></span> <code class="nx">len</code><code class="p">;</code> <span class="pd_ash"><code class="nx">i</code><code class="o">++</code></span><code class="p">){</code>
                   <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><code class="nx">listeners</code><code class="p">[</code><span class="pd_ash"><code class="nx">i</code></span><code class="p">]</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">listener</code><code class="p">){</code>
                       <code class="nx">listeners</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code> <span class="pd_ash"><code class="mi">1</code></span><code class="p">);</code>
                       <span class="pd_green"><code class="k">break</code></span><code class="p">;</code>
                   <code class="p">}</code>
              <code class="p">}</code>
          <code class="p">}</code>
      <code class="p">}</code>
 <code class="p">};</code></pre><p>The <code class="literal">EventTarget</code> type provides basic event handling for any object. You can add ❶ and remove ❸ listeners as well as fire events ❷ directly on the object. The event listeners are stored on a <code class="literal">_listeners</code> property that is created only when <code class="literal">addListener()</code> is called for the first time (this makes it easier to mix in). You can use instances of <code class="literal">EventTarget</code> like this:</p><a id="pro_id00122"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">target</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">();</code>
<code class="nx">target</code><code class="p">.</code><code class="nx">addListener</code><code class="p">(</code><span class="pd_red"><code class="s2">"message"</code></span><code class="p">,</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"Message is "</code></span> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">);</code>
<code class="p">})</code>

<code class="nx">target</code><code class="p">.</code><code class="nx">fire</code><code class="p">({</code>
    <code class="nx">type</code><code class="o">:</code> <span class="pd_red"><code class="s2">"message"</code></span><code class="p">,</code>
    <code class="nx">data</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Hello world!"</code></span>
<code class="p">});</code></pre><p>Support for events is useful for objects in JavaScript. If you want to have a different type of object that also supports events, you have a few options. First, you can create a new instance of <code class="literal">EventTarget</code> and then add on the properties that you want:</p><a id="pro_id00123"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">();</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">;</code>
<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><span class="pd_ash"><code class="o">:</code></span> <span class="pd_red"><code class="s2">"namesaid"</code></span><code class="p">,</code> <code class="nx">name</code><span class="pd_ash"><code class="o">:</code></span> <code class="nx">name</code> <code class="p">});</code>
<code class="p">};</code></pre><p>In this code, a new variable called <code class="literal">person</code> is created as an instance of <code class="literal">EventTarget</code>, and then the <code class="literal">person</code>-related properties are added. Unfortunately, this means that <code class="literal">person</code> is actually an instance of <code class="literal">EventTarget</code> instead of <code class="literal">Object</code> or a custom type. You also incur the overhead of needing to add a bunch of new properties by hand. It would be better to have a more organized way of doing this.</p><p><a id="iddle1151" class="indexterm"/><a id="iddle1308" class="indexterm"/>A second way to solve this problem is to use pseudoclassical inheritance:</p><a id="pro_id00124"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

<code class="err">❶</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">EventTarget</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">Person</code><code class="p">;</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <code class="o">=</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><span class="pd_ash"><code class="o">:</code></span> <span class="pd_ash"><code class="s2">"namesaid"</code></span><code class="p">,</code> <code class="nx">name</code><span class="pd_ash"><code class="o">:</code></span> <code class="nx">name</code> <code class="p">});</code>
  <code class="p">};</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">EventTarget</code><code class="p">);</code> <span class="pd_green1"><code class="c1">// true</code></span></pre><p>In this case, there is a new <code class="literal">Person</code> type that inherits from <code class="literal">EventTarget</code> ❶. You can add any further methods you need to <code class="literal">Person</code>’s prototype afterward. However, this isn’t as succinct as it could be, and you could argue that the relationship doesn’t make sense: A person is a type of event target? By using a mixin instead, you can reduce the amount of code necessary to assign those new properties to the prototype:</p><a id="pro_id00125"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="err">❶</code> <code class="nx">mixin</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">());</code>
  <code class="nx">mixin</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">constructor</code><code class="o">:</code> <code class="nx">Person</code><code class="p">,</code>

      <code class="nx">sayName</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
          <code class="k">this</code><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"namesaid"</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">name</code> <code class="p">});</code>
      <code class="p">}</code>
  <code class="p">});</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">EventTarget</code><code class="p">);</code> <span class="pd_green1"><code class="c1">// false</code></span></pre><p>Here, <code class="literal">Person.prototype</code> is mixed in with a new instance of <code class="literal">EventTarget</code> ❶ to get the event behavior. Then, <code class="literal">Person.prototype</code> is mixed in with <code class="literal">constructor</code> and <code class="literal">sayName()</code> to complete the composition of the prototype. Instances of <code class="literal">Person</code> are not instances of <code class="literal">EventTarget</code> in this example because there is no inheritance.</p><p><a id="iddle1080" class="indexterm"/><a id="iddle1190" class="indexterm"/>Of course, you might decide that while you do want to use an object’s properties, you don’t want a constructor of pseudoclassical inheritance at all. In that case, you can use a mixin directly when you create your new object:</p><a id="pro_id00126"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">mixin</code><code class="p">(</code><span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">(),</code> <code class="p">{</code>

    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>

    <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
        <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><span class="pd_ash"><code class="o">:</code></span> <span class="pd_red"><code class="s2">"namesaid"</code></span><code class="p">,</code> <code class="nx">name</code><span class="pd_ash"><code class="o">:</code></span> <code class="nx">name</code> <code class="p">});</code>
    <code class="p">}</code>
<code class="p">});</code></pre><p>In this example, a new instance of <code class="literal">EventTarget</code> is mixed in with some new properties to create the <code class="literal">person</code> object without affecting <code class="literal">person</code>’s prototype chain.</p><p>One thing to keep in mind about using mixins in this way is that accessor properties on the supplier become data properties on the receiver, which means you can overwrite them if you’re not careful. That’s because the receiver properties are being created by assignment rather than by <code class="literal">Object.defineProperty()</code>, meaning the current value of the supplier property is read and then assigned to a property of the same name on the receiver. For example:</p><a id="pro_id00127"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">mixin</code><code class="p">(</code><span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">(),</code> <code class="p">{</code>

<code class="err">❶</code>     <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span>
      <code class="p">},</code>

      <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
          <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><span class="pd_ash"><code class="o">:</code></span> <span class="pd_red"><code class="s2">"namesaid"</code></span><code class="p">,</code> <code class="nx">name</code><span class="pd_ash"><code class="o">:</code></span> <code class="nx">name</code> <code class="p">});</code>
      <code class="p">}</code>
  <code class="p">});</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>        <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>

<code class="err">❷</code> <code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>        <span class="pd_green1"><code class="c1">// "Greg"</code></span></pre><p><a id="iddle1172" class="indexterm"/><a id="iddle1224" class="indexterm"/>In this code, <code class="literal">name</code> is defined as an accessor property with only a getter ❶. That means assigning a value to the property should have no effect. However, because the accessor property becomes a data property on the <code class="literal">person</code> object, it’s possible to overwrite <code class="literal">name</code> with a new value ❷. During the call to <code class="literal">mixin()</code>, the value of <code class="literal">name</code> is read from the supplier and assigned to the property called <code class="literal">name</code> on the receiver. At no point during this process is a new accessor defined, making the <code class="literal">name</code> property on the receiver a data property.</p><p>If you want accessor properties to be copied over as accessor properties, you need a different <code class="literal">mixin()</code> function, such as:</p><a id="pro_id00128"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">mixin</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>
<code class="err">❶</code>     <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">supplier</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="p">{</code>
          <span class="pd_green"><code class="kd">var</code></span> <code class="nx">descriptor</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">supplier</code><code class="p">,</code> <code class="nx">property</code><code class="p">);</code>
<code class="err">❷</code>         <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">);</code>
      <code class="p">});</code>

      <span class="pd_green"><code class="k">return</code></span> <code class="nx">receiver</code><code class="p">;</code>
  <code class="p">}</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">mixin</code><code class="p">(</code><span class="pd_green"><code class="k">new</code></span> <code class="nx">EventTarget</code><code class="p">(),</code> <code class="p">{</code>

      <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"Nicholas"</code></span>
      <code class="p">},</code>

      <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
          <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">fire</code><code class="p">({</code> <code class="nx">type</code><span class="pd_ash"><code class="o">:</code></span> <span class="pd_red"><code class="s2">"namesaid"</code></span><code class="p">,</code> <code class="nx">name</code><span class="pd_ash"><code class="o">:</code></span> <code class="nx">name</code> <code class="p">});</code>
      <code class="p">}</code>
  <code class="p">});</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>

  <code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "Nicholas"</code></span></pre><p>This version of <code class="literal">mixin()</code> uses <code class="literal">Object.keys()</code> ❶ to get an array of all enumerable own properties on <code class="literal">supplier</code>. The <code class="literal">forEach()</code> method is used to iterate over those properties. The property descriptor for each property on <code class="literal">supplier</code> is retrieved and then added to <code class="literal">receiver</code> via <code class="literal">Object.defineProperty()</code> ❷. This ensures that all of the relevant property information is transferred to <code class="literal">receiver</code>, not just the value. That means the <code class="literal">person</code> object has an accessor property called <code class="literal">name</code>, so it cannot be overwritten.</p><p><a id="iddle1064" class="indexterm"/><a id="iddle1196" class="indexterm"/><a id="iddle1326" class="indexterm"/>Of course, this version of <code class="literal">mixin()</code> works only in ECMAScript 5 JavaScript engines. If your code needs to work for older engines, you should combine the two <code class="literal">mixin()</code> approaches into a single function:</p><a id="pro_id00129"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">mixin</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>

<code class="err">❶</code>     <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">)</code> <code class="p">{</code>

          <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">supplier</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="p">{</code>
              <span class="pd_green"><code class="kd">var</code></span> <code class="nx">descriptor</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">supplier</code><code class="p">,</code> <code class="nx">property</code><code class="p">);</code>
              <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">);</code>
          <code class="p">});</code>

      <code class="p">}</code> <span class="pd_green"><code class="k">else</code></span> <code class="p">{</code>

<code class="err">❷</code>         <span class="pd_green"><code class="k">for</code></span> <code class="p">(</code><span class="pd_green"><code class="kd">var</code></span> <code class="nx">property</code> <span class="pd_green"><code class="k">in</code></span> <code class="nx">supplier</code><code class="p">)</code> <code class="p">{</code>
              <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><code class="nx">supplier</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">property</code><code class="p">))</code> <code class="p">{</code>
                  <code class="nx">receiver</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">supplier</code><code class="p">[</code><code class="nx">property</code><code class="p">]</code>
              <code class="p">}</code>
          <code class="p">}</code>
      <code class="p">}</code>

      <span class="pd_green"><code class="k">return</code></span> <code class="nx">receiver</code><code class="p">;</code>
  <code class="p">}</code></pre><p>Here, <code class="literal">mixin()</code> checks whether <code class="literal">Object.getOwnPropertyDescriptor()</code> ❶ exists to determine whether the JavaScript engine supports ECMAScript 5. If so, it goes on to use the ECMAScript 5 version. Otherwise, the ECMAScript 3 version is used ❷. This function is safe to use in both modern and legacy JavaScript engines, as they will apply the most appropriate mixin strategy.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><span class="emphasis"><em>Keep in mind that Object.keys() returns only enumerable properties. If you want to also copy over nonenumerable properties, use <code class="literal">Object.getOwnPropertyNames()</code> instead.</em></span></p></div></div><div class="sect1" title="Scope-Safe Constructors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="scope-safe_constructors">Scope-Safe Constructors</h2></div></div></div><p>Because all constructors are just functions, you can call them without using the <code class="literal">new</code> operator and therefore affect the value of <code class="literal">this</code>. Doing so can yield unexpected results, as <code class="literal">this</code> ends up coerced to the global object in nonstrict mode, or the constructor throws an error in strict mode. In <a class="xref" href="ch04.html" title="Chapter 4. Constructors and Prototypes">Chapter 4</a>, you encountered this example:</p><a id="pro_id00130"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
  <code class="p">};</code>

<code class="err">❶</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>           <span class="pd_green1"><code class="c1">// note: missing "new"</code></span>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// false</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">person1</code><code class="p">);</code>                <span class="pd_green1"><code class="c1">// "undefined"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>                          <span class="pd_green1"><code class="c1">// "Nicholas"</code></span></pre><p>In this case, <code class="literal">name</code> is created as a global variable because the <code class="literal">Person</code> constructor is called without <code class="literal">new</code> ❶. Keep in mind that this code is running in nonstrict mode, as leaving out <code class="literal">new</code> would throw an error in strict mode. The fact that the constructor begins with a capital letter usually indicates that it should be preceded by <code class="literal">new</code>, but what if you want to allow this use case and have the function work without <code class="literal">new</code>? Many built-in constructors, such as <code class="literal">Array</code> and <code class="literal">RegExp</code>, also work without <code class="literal">new</code> because they are written to be <span class="emphasis"><em>scope safe</em></span>. A scope-safe constructor can be called with or without <code class="literal">new</code> and returns the same type of object in either case.</p><p>When <code class="literal">new</code> is called with a function, the newly created object represented by <code class="literal">this</code> is already an instance of the custom type represented by the constructor. So you can use <code class="literal">instanceof</code> to determine whether <code class="literal">new</code> was used in the function call:</p><a id="pro_id00131"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="k">this</code> <code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>
        <span class="pd_green1"><code class="c1">// called with "new"</code></span>
    <code class="p">}</code> <span class="pd_green"><code class="k">else</code></span> <code class="p">{</code>
        <span class="pd_green1"><code class="c1">// called without "new"</code></span>
    <code class="p">}</code>
<code class="p">}</code></pre><p>Using a pattern like this lets you control what a function does based on whether it’s called with <code class="literal">new</code> or without. You may want to treat each circumstance differently, but you’ll often want the function to behave the same way (frequently, to protect against accidental omission of <code class="literal">new</code>). A scope-safe version of <code class="literal">Person</code> looks like this:</p><a id="pro_id00132"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><span class="pd_green"><code class="k">this</code> <code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">)</code> <code class="p">{</code>
        <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code> <span class="pd_green"><code class="k">else</code></span> <code class="p">{</code>
        <span class="pd_green"><code class="k">return</code> <code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre><p>For this constructor, the <code class="literal">name</code> property is assigned as always when <code class="literal">new</code> is used. If <code class="literal">new</code> isn’t used, the constructor is called recursively via <code class="literal">new</code> to create a proper instance of the object. In this way, the following are equivalent:</p><a id="pro_id00133"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span></pre><p>Creating new objects without using the <code class="literal">new</code> operator is becoming more common as an effort to curb errors caused by omitting <code class="literal">new</code>. JavaScript itself has several reference types with scope-safe constructors, such as <code class="literal">Object</code>, <code class="literal">Array</code>, <code class="literal">RegExp</code>, and <code class="literal">Error</code>.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00007">Summary</h2></div></div></div><p>There are many different ways to create and compose objects in JavaScript. While JavaScript does not include the formal concept of private properties, you can create data or functions that are accessible only from within an object. For singleton objects, you can use the module pattern to hide data from the outside world. You can use an immediately invoked function expression (IIFE) to define local variables and functions that are accessible only by the newly created object. Privileged methods are methods on the object that have access to private data. You can also create constructors that have private data by either defining variables in the constructor function or by using an IIFE to create private data that is shared among all instances.</p><p>Mixins are a powerful way to add functionality to objects while avoiding inheritance. A mixin copies properties from one object to another so that the receiving object gains functionality without inheriting from the supplying object. Unlike inheritance, mixins do not allow you to identify where the capabilities came from after the object is created. For this reason, mixins are best used with data properties or small pieces of functionality. Inheritance is still preferable when you want to obtain more functionality and know where that functionality came from.</p><p>Scope-safe constructors are constructors that you can call with or without <code class="literal">new</code> to create a new object instance. This pattern takes advantage of the fact that <code class="literal">this</code> is an instance of the custom type as soon as the constructor begins to execute, which lets you alter the constructor’s behavior depending on whether or not you used the <code class="literal">new</code> operator.</p></div></section></body></html>
